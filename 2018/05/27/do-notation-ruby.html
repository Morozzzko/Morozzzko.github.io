<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Railway Oriented programming in Ruby: do notation vs dry-transaction - Igor writing about things</title>
<meta name="description" content="Railway oriented programming is a design pattern which helps us handle errors in our applications. Instead of relying on exceptions, we design our data and functions in a specific way. Since applications are essentially just a combination of steps, we’ll make some design decisions about those steps and their structure:     There is a Result type, which can be either a Success or a Failure   Success and Failure are practically containers with different data   Steps accept Result and return Result   Once a step returns Failure, we stop further execution   I want to emphasize that Result is just an alternative name for the Either monad. Railway Oriented Programming comes from functional programming, so it is tightly related to the usual FP concepts like monads, composition, and many others. However, you don’t need to have an extensive knowledge of monads to use ROP in your code. In this article, I’ll show you how to write railway-oriented code in Ruby.">


  <meta name="author" content="Igor Morozov">
  
  <meta property="article:author" content="Igor Morozov">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Igor writing about things">
<meta property="og:title" content="Railway Oriented programming in Ruby: do notation vs dry-transaction">
<meta property="og:url" content="https://www.morozov.is/2018/05/27/do-notation-ruby.html">


  <meta property="og:description" content="Railway oriented programming is a design pattern which helps us handle errors in our applications. Instead of relying on exceptions, we design our data and functions in a specific way. Since applications are essentially just a combination of steps, we’ll make some design decisions about those steps and their structure:     There is a Result type, which can be either a Success or a Failure   Success and Failure are practically containers with different data   Steps accept Result and return Result   Once a step returns Failure, we stop further execution   I want to emphasize that Result is just an alternative name for the Either monad. Railway Oriented Programming comes from functional programming, so it is tightly related to the usual FP concepts like monads, composition, and many others. However, you don’t need to have an extensive knowledge of monads to use ROP in your code. In this article, I’ll show you how to write railway-oriented code in Ruby.">



  <meta property="og:image" content="https://www.morozov.is/assets/images/previews/do_notation.png">





  <meta property="article:published_time" content="2018-05-27T10:25:00+00:00">






<link rel="canonical" href="https://www.morozov.is/2018/05/27/do-notation-ruby.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Igor Morozov",
      "url": "https://www.morozov.is/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Igor writing about things Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <a href="/">
          <img src="/assets/images/bio-photo.jpg" alt="Igor Morozov" itemprop="image">
        </a>
      
    </div>
  

  <div class="author__content">
    
      <a href="/"><h3 class="author__name" itemprop="name">Igor Morozov</h3></a>
    
    
      <div class="author__bio" itemprop="description">
        <p>I’m a software engineer from Russia
<br />
Familiar with Ruby and many other things
<br />
Enthusiastic about Ruby, DDD, FP, OOP, software architecture and emotions.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      

      
        <li>
          <a href="mailto:igor@morozov.is">
            <meta itemprop="email" content="igor@morozov.is" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/morozzzko" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span>
          </a>
        </li>
      

      

      
        <li>
          <a href="https://www.linkedin.com/in/igor-morozov" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span>
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/Morozzzko" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      
<li>
  <a href="/talks" itemprop="sameAs">
    <i class="fas fa-chalkboard-teacher" aria-hidden="true"></i> Talks
  </a>
</li>

    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Railway Oriented programming in Ruby: do notation vs dry-transaction">
    <meta itemprop="description" content="Railway oriented programming is a design pattern which helps ushandle errors in our applications. Instead of relying on exceptions,we design our data and functions in a specific way. Since applicationsare essentially just a combination of steps, we’ll make some design decisionsabout those steps and their structure:  There is a Result type, which can be either a Success or a Failure  Success and Failure are practically containers with different data  Steps accept Result and return Result  Once a step returns Failure, we stop further executionI want to emphasize that Result is just an alternative name for the Eithermonad. Railway Oriented Programming comes from functional programming,so it is tightly related to the usual FP concepts like monads, composition, and manyothers. However, you don’t need to have an extensive knowledge of monads touse ROP in your code. In this article, I’ll show you how to write railway-orientedcode in Ruby.">
    <meta itemprop="datePublished" content="2018-05-27T10:25:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Railway Oriented programming in Ruby: do notation vs dry-transaction
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Railway oriented programming is a design pattern which helps us
handle errors in our applications. Instead of relying on exceptions,
we design our data and functions in a specific way. Since applications
are essentially just a combination of steps, we’ll make some design decisions
about those steps and their structure:</p>

<ul>
  <li>There is a <code class="language-plaintext highlighter-rouge">Result</code> type, which can be either a <code class="language-plaintext highlighter-rouge">Success</code> or a <code class="language-plaintext highlighter-rouge">Failure</code></li>
  <li><code class="language-plaintext highlighter-rouge">Success</code> and <code class="language-plaintext highlighter-rouge">Failure</code> are practically containers with different data</li>
  <li>Steps accept <code class="language-plaintext highlighter-rouge">Result</code> and return <code class="language-plaintext highlighter-rouge">Result</code></li>
  <li>Once a step returns <code class="language-plaintext highlighter-rouge">Failure</code>, we stop further execution</li>
</ul>

<p>I want to emphasize that <code class="language-plaintext highlighter-rouge">Result</code> is just an alternative name for the <code class="language-plaintext highlighter-rouge">Either</code>
monad. Railway Oriented Programming comes from functional programming,
so it is tightly related to the usual FP concepts like monads, composition, and many
others. However, you don’t need to have an extensive knowledge of monads to
use ROP in your code. In this article, I’ll show you how to write railway-oriented
code in Ruby.</p>

<!-- excerpt -->

<h2 id="rop-with-dry-transaction">ROP with dry-transaction</h2>

<p>There is a <a href="http://dry-rb.org/gems/dry-transaction/">dry-transaction</a> gem
which provides a DSL to build railway-oriented business transactions.
The core part of the gem is <a href="http://dry-rb.org/gems/dry-monads/">dry-monads</a>
which provides the <a href="http://dry-rb.org/gems/dry-monads/result/"><code class="language-plaintext highlighter-rouge">Result</code> type</a>
and tools to work with it.</p>

<p>To create a railway-oriented operation, we’ll need to do a few things:</p>

<ul>
  <li>Create a class and <code class="language-plaintext highlighter-rouge">include Dry::Transaction</code></li>
  <li>Define a few methods that return either <code class="language-plaintext highlighter-rouge">Success</code> or <code class="language-plaintext highlighter-rouge">Failure</code></li>
  <li>Use step adapters to chain those methods together</li>
</ul>

<p>Then, we can instantiate the class and pass any input to the <code class="language-plaintext highlighter-rouge">#call</code> method.</p>

<p>Here’s how it looks like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyOperation</span>
  <span class="kp">include</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Transaction</span>
  <span class="kp">include</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Monads</span>

  <span class="n">step</span> <span class="ss">:validate</span>
  <span class="n">step</span> <span class="ss">:log</span>
  <span class="n">step</span> <span class="ss">:persist</span>

  <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">.</span><span class="nf">valid?</span>
      <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="n">data</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="ss">age: </span><span class="n">data</span><span class="p">.</span><span class="nf">user_age</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">Failure</span><span class="p">(</span><span class="s2">"something went wrong"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="nb">name</span><span class="p">:,</span> <span class="o">**</span><span class="n">rest</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"User name is </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="o">**</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="nb">name</span><span class="p">:,</span> <span class="n">age</span><span class="p">:)</span>
    <span class="o">...</span>
    <span class="c1"># some business logic here</span>
    <span class="o">...</span>
    <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">age: </span><span class="n">age</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">MyOperation</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="c1"># ^ can return either</span>
<span class="c1"># Success(name: ..., age: ...)</span>
<span class="c1"># or Failure("something went wrong")</span>
</code></pre></div></div>

<p>As you can see, we use class-level <code class="language-plaintext highlighter-rouge">step</code> method to compose the <code class="language-plaintext highlighter-rouge">validate</code>,
<code class="language-plaintext highlighter-rouge">log</code> and <code class="language-plaintext highlighter-rouge">persist</code> methods. <code class="language-plaintext highlighter-rouge">Failure</code> returned from <code class="language-plaintext highlighter-rouge">validate</code> halts the
further execution.</p>

<p>Pros of the approach:</p>

<ul>
  <li>It’s plain Ruby</li>
  <li>It allows us to reuse steps</li>
  <li>It works!</li>
  <li>Chained methods don’t need to unwrap the input</li>
</ul>

<p>Cons of the approach:</p>

<ul>
  <li>The DSL has a weaker control over the program’s flow — we can’t have conditions unless we add a special step</li>
  <li>The <code class="language-plaintext highlighter-rouge">Result</code> object that we pass around keeps accumulating data and becomes
enormous, so we have to use <code class="language-plaintext highlighter-rouge">**rest</code> in our function signatures</li>
  <li>Database transactions were hard to implement until <a href="http://dry-rb.org/gems/dry-transaction/around-steps/">around step</a> came around. Still awkward, though</li>
</ul>

<h2 id="dry-monads-to-the-rescue">dry-monads to the rescue</h2>

<p>Since dry-transaction is based on dry-monads, we could probably build something
ourselves, right?</p>

<p><code class="language-plaintext highlighter-rouge">Result</code> has a few methods to help us chain those monads:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bind</code> applies unwrapped <code class="language-plaintext highlighter-rouge">Success</code> value to the block, which should return a <code class="language-plaintext highlighter-rouge">Result</code> object. No-op on <code class="language-plaintext highlighter-rouge">Failure</code></li>
  <li><code class="language-plaintext highlighter-rouge">fmap</code> is similar to <code class="language-plaintext highlighter-rouge">bind</code>, but wraps the returned value into <code class="language-plaintext highlighter-rouge">Success</code></li>
  <li><code class="language-plaintext highlighter-rouge">or</code> is similar to <code class="language-plaintext highlighter-rouge">bind</code>, but only applies <code class="language-plaintext highlighter-rouge">Failure</code> values</li>
  <li><code class="language-plaintext highlighter-rouge">or_fmap</code> is similar to <code class="language-plaintext highlighter-rouge">or</code>, but wraps the returned value into <code class="language-plaintext highlighter-rouge">Success</code></li>
  <li><code class="language-plaintext highlighter-rouge">tee</code> does the same thing as <code class="language-plaintext highlighter-rouge">bind</code>, but returns input if the result is a <code class="language-plaintext highlighter-rouge">Success</code></li>
  <li><code class="language-plaintext highlighter-rouge">success?</code> and <code class="language-plaintext highlighter-rouge">failure?</code> tell us which kind of <code class="language-plaintext highlighter-rouge">Result</code> it is</li>
  <li><code class="language-plaintext highlighter-rouge">value_or</code> extracts the value from <code class="language-plaintext highlighter-rouge">Success</code> or returns fallback value</li>
</ul>

<p>This is how the same example would look like using raw monads:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyOperation</span>
  <span class="kp">include</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Monads</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">validate</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="nf">bind</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:log</span><span class="p">)).</span><span class="nf">bind</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:persist</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">.</span><span class="nf">valid?</span>
      <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="n">data</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="ss">age: </span><span class="n">data</span><span class="p">.</span><span class="nf">user_age</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">Failure</span><span class="p">(</span><span class="s2">"something went wrong"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="nb">name</span><span class="p">:,</span> <span class="o">**</span><span class="n">rest</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"User name is </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="o">**</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="nb">name</span><span class="p">:,</span> <span class="n">age</span><span class="p">:)</span>
    <span class="o">...</span>
    <span class="c1"># some business logic here</span>
    <span class="o">...</span>
    <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">age: </span><span class="n">age</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The differences:</p>

<ul>
  <li>Plain methods instead of a DSL</li>
  <li>Better control over flow of our application: more ways to add branching</li>
</ul>

<p>However, there are some disadvantages to the approach</p>

<ul>
  <li>Having to use <code class="language-plaintext highlighter-rouge">#method</code> is hideous. Solution? Callable objects</li>
  <li>We still have to pass <strong>all</strong> parameters to each function</li>
  <li>Complex logic gets awkward as we add more steps to the chain</li>
  <li>It doesn’t halt execution if a function returned a <code class="language-plaintext highlighter-rouge">Failure</code>, so we’ll have
to work around that</li>
</ul>

<p>Since 1.0.0.beta1 of dry-monads, there’s a solution to the problems: do notation.</p>

<h2 id="do-notation-in-ruby">Do notation in Ruby</h2>

<p>When we work with monads and <code class="language-plaintext highlighter-rouge">Result</code> in particular, we have to constantly <code class="language-plaintext highlighter-rouge">bind</code>
them together. When we introduce complex logic with conditions, we end up with
nested binds, and those are hard to work with. Do notation provides an alternative
to <code class="language-plaintext highlighter-rouge">bind</code>, which also flattens the code.</p>

<p>So we can replace this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">validate</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="nf">bind</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:log</span><span class="p">)).</span><span class="nf">bind</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:log</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>With that:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">validated_data</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="k">yield</span> <span class="n">log</span><span class="p">(</span><span class="n">validated_data</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>
  <span class="n">persist</span><span class="p">(</span><span class="n">validated_data</span><span class="p">)</span> <span class="c1"># &lt;= You don't need to `yield` the last expression</span>
<span class="k">end</span>
</code></pre></div></div>

<p>or even that:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">validated_data</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="n">log</span><span class="p">(</span><span class="n">validated_data</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>
  <span class="n">persist</span><span class="p">(</span><span class="n">validated_data</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sounds cool, right? We had to use <code class="language-plaintext highlighter-rouge">bind</code> to chain those operations. Now we
can just <code class="language-plaintext highlighter-rouge">yield</code> the steps that can fail and keep the code flat.</p>

<p>This is how our operation looks with do notation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyOperation</span>
  <span class="kp">include</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Monads</span>
  <span class="kp">include</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Monads</span><span class="o">::</span><span class="no">Do</span><span class="p">.</span><span class="nf">for</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">validated_data</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">log</span><span class="p">(</span><span class="n">validated_data</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>

    <span class="n">persist</span><span class="p">(</span><span class="n">validated_data</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">.</span><span class="nf">valid?</span>
      <span class="no">Success</span><span class="p">(</span><span class="ss">name: </span><span class="n">data</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="ss">age: </span><span class="n">data</span><span class="p">.</span><span class="nf">user_age</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">Failure</span><span class="p">(</span><span class="s2">"something went wrong"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"User name is </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">persist</span><span class="p">(</span><span class="nb">name</span><span class="p">:,</span> <span class="n">age</span><span class="p">:)</span>
    <span class="o">...</span>
    <span class="c1"># some business logic here</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The core points:</p>

<ul>
  <li>A new mixin: <code class="language-plaintext highlighter-rouge">Dry::Monads::Do.for(:call)</code></li>
  <li><code class="language-plaintext highlighter-rouge">yield</code> halts the execution if the function returns <code class="language-plaintext highlighter-rouge">Failure</code></li>
  <li>No need to unwrap the monad: <code class="language-plaintext highlighter-rouge">yield</code> does it for us</li>
  <li><code class="language-plaintext highlighter-rouge">log</code> and <code class="language-plaintext highlighter-rouge">persist</code> no longer need to return <code class="language-plaintext highlighter-rouge">Result</code> as they don’t affect the flow</li>
  <li>We don’t have to stick to declarative style anymore</li>
  <li>No need to <code class="language-plaintext highlighter-rouge">yield</code> the last expression — Ruby handles it for you</li>
  <li>Last expression <strong>must</strong> return <code class="language-plaintext highlighter-rouge">Result</code></li>
</ul>

<h2 id="performance">Performance</h2>

<p>The reason I wrote the article is that I wanted to benchmark do notation
and compare its performance against dry-transaction.</p>

<p>The questions I wanted to answer:</p>

<ul>
  <li>Is do-notation faster than dry-transaction?</li>
  <li>What are the performance differences between happy and not-so-happy paths?</li>
  <li>What kind of performance drop do we have as we add more steps?</li>
</ul>

<p>So I wrote a <a href="https://github.com/Morozzzko/benchmarking-dry">simple benchmark</a>
to test those things. Design decisions:</p>

<ul>
  <li>No IO or loops</li>
  <li>Simple arithmetics is good enough</li>
  <li>Objects behave like pure functions</li>
</ul>

<p>The algorithm I tested looks as follows:</p>

<ul>
  <li>Multiply input by 2</li>
  <li>If the result is greater than 100, return an error</li>
  <li>Add 2</li>
</ul>

<p>Total: 3 steps.</p>

<p>Benchmark output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warming up --------------------------------------
  do-notation: happy    33.809k i/100ms
do-notation: failure    14.274k i/100ms
  transaction: happy     5.878k i/100ms
transaction: failure     5.867k i/100ms
Calculating -------------------------------------
  do-notation: happy    387.914k (± 1.4%) i/s -      1.961M in   5.056134s
do-notation: failure    152.445k (± 1.7%) i/s -    770.796k in   5.057752s
  transaction: happy     59.981k (± 3.0%) i/s -    299.778k in   5.002999s
transaction: failure     60.327k (± 1.5%) i/s -    305.084k in   5.058375s

Comparison:
  do-notation: happy:   387913.7 i/s
do-notation: failure:   152445.2 i/s - 2.54x  slower
transaction: failure:    60327.4 i/s - 6.43x  slower
  transaction: happy:    59981.0 i/s - 6.47x  slower
</code></pre></div></div>

<p>So what do we see:</p>

<ul>
  <li>dry-transaction performance isn’t really affected by failures</li>
  <li>do notation becomes approximately 2.5 times slower if we get a <code class="language-plaintext highlighter-rouge">Failure</code></li>
  <li>Do notation is over <em>six</em> times faster than dry-transaction</li>
</ul>

<h2 id="heavier-benchmark">Heavier benchmark</h2>

<p>Alright, so we had a benchmark that worked with three steps that could
<em>theoretically</em> return <code class="language-plaintext highlighter-rouge">Failure</code>. But real-world apps are way more complex
than that. So I decided to add more steps and see what happens.</p>

<p>Algorithm:</p>

<ul>
  <li>Multiply input by 2</li>
  <li>Add 2 three times</li>
  <li>If the result is greater than 100, return an error</li>
  <li>Add 2 four times</li>
</ul>

<p>Total: 9 steps.</p>

<p>Benchmark output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warming up --------------------------------------
  do-notation: happy    10.384k i/100ms
do-notation: failure     9.282k i/100ms
  transaction: happy     2.084k i/100ms
transaction: failure     2.083k i/100ms
Calculating -------------------------------------
  do-notation: happy    108.311k (± 1.3%) i/s -    550.352k in   5.082157s
do-notation: failure     89.917k (± 6.9%) i/s -    454.818k in   5.086821s
  transaction: happy     21.047k (± 2.1%) i/s -    106.284k in   5.052038s
transaction: failure     21.047k (± 1.5%) i/s -    106.233k in   5.048585s

Comparison:
  do-notation: happy:   108310.5 i/s
do-notation: failure:    89917.5 i/s - 1.20x  slower
  transaction: happy:    21047.4 i/s - 5.15x  slower
transaction: failure:    21047.1 i/s - 5.15x  slower
</code></pre></div></div>

<p>So what do we see <em>here</em>:</p>

<ul>
  <li>
    <p>Happy path is not that much faster than not-so-happy path</p>

    <p>That’s because happy path still has to evaluate the remaining steps. It takes time.</p>
  </li>
  <li>dry-transaction still shows similar performance for both outcomes</li>
  <li>dry-transaction is five times slower than do notation</li>
</ul>

<h2 id="facts--conclusion">Facts &amp; conclusion</h2>

<ul>
  <li>Railway Oriented Programming is a way to gracefully handle errors in your
application</li>
  <li>You can use dry-monads and dry-transactions to build railway-oriented services</li>
  <li>Functions can return either <code class="language-plaintext highlighter-rouge">Success</code> or <code class="language-plaintext highlighter-rouge">Failure</code>, which form the <code class="language-plaintext highlighter-rouge">Result</code> monad</li>
  <li>Dry-transaction provides a DSL for railway oriented programming</li>
  <li>Use <code class="language-plaintext highlighter-rouge">bind</code>, <code class="language-plaintext highlighter-rouge">fmap</code>, <code class="language-plaintext highlighter-rouge">or</code> and <code class="language-plaintext highlighter-rouge">or_fmap</code> to build railway-oriented code in Ruby</li>
  <li>Use do notation to have a better control over your program’s flow</li>
  <li>Do notation is <strong>way</strong> faster and more flexible than dry-transaction</li>
  <li>This approach is framework-agnostic: works with Rails, Hanami, Sinatra, dry-web-roda</li>
</ul>

<p>Also, there’s a visible lack of documentation for dry-monads, so if you decide to give it a try, you are welcome to contribute!</p>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://dry-rb.org/gems/dry-transaction">dry-transaction</a></li>
  <li><a href="https://dry-rb.org/gems/dry-monads">dry-monads</a></li>
  <li><a href="http://zohaib.me/railway-programming-pattern-in-elixir/">Railway Oriented Programming in Elixir</a></li>
  <li><a href="https://fsharpforfunandprofit.com/rop/">Slides on ROP</a> at F# for fun and profit</li>
  <li><a href="https://fsharpforfunandprofit.com/posts/recipe-part2/">Article on ROP</a> at F# for fun and profit</li>
  <li><a href="https://medium.com/pepegramming/do-notation-1e0840a6dbe0">🇷🇺 Anton Davydov on DO notation </a></li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-05-27T10:25:00+00:00">May 27, 2018</time></p>


      </footer>

      <section class="page__share">
    
        <a href="https://www.reddit.com/r/ruby/comments/8mzne8/railway_oriented_programming_in_ruby_do_notation/" class="btn btn--reddit" title="Discuss @ Reddit">
            <i class="fab fa-fw fa-reddit" aria-hidden="true"></i><span> See discussion @ Reddit</span>
        </a>
    

    <a href="https://twitter.com/intent/tweet?text=Railway+Oriented+programming+in+Ruby%3A+do+notation+vs+dry-transaction%20https%3A%2F%2Fwww.morozov.is%2F2018%2F05%2F27%2Fdo-notation-ruby.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.morozov.is%2F2018%2F05%2F27%2Fdo-notation-ruby.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fwww.morozov.is%2F2018%2F05%2F27%2Fdo-notation-ruby.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>



      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">Previous</a>
    
    
      <a href="/2018/09/08/monad-laws-in-ruby.html" class="pagination--pager" title="Monad laws in Ruby
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Igor Morozov. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
