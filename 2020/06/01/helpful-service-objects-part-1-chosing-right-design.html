<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Designing helpful service objects. Part 1. Choosing the right design - Igor writing about things</title>
<meta name="description" content="I’ve been programming for a long time and I’ve had countless arguments about different things. I’d like to list top four reasons I’ve had an argument online.  Style guide. Thankfully, the number of arguments reduces as I mature, but I’m still spending a lot of time on them. I’d rather have an extremely opinionated styleguide and just stop talking about it. Something like wemake-python-styleguide, but for Ruby.  Monads. I have to admit that this word is almost banned from my vocabulary because of how many arguments I’ve had about it. It’s getting better, but people still like to argue about them. I wrote an article recently about them in hope to show that there’s nothing special to argue about – monads are just abstractions that may or may not be helpful. It all depends on your problems and approaches.  How to design domain logic. It may be an extremely interesting and helpful discussion, or it may turn into a useless argument. When it goes bad, it’s usually because we’re trying to discuss insignificant details and lower-level things. Where do we put arguments? What about dependency injection? How do we use instance variables? Fat model? Service objects? Ughh!  Different interpretation of common terminology. What do we mean when we say “interactor”? What about “architecture”? Is it a state when we’re just passing values from function to function? Is duck typing really an absence of types? What is a type, anyway? What does it mean to write “object oriented” code? What about “functional” approach? Do we need immutability in OO design? Those topics lead to endless discussions with little output.  As much as I love learning about new things, those arguments are extremely energy-draining. They got me thinking: since we’re usually going over the same thing, why don’t we just dump the knowledge somewhere and refer to it instead of arguing? That’s what I’m going to do.  I’m starting a series of blog posts about different topics in Ruby world. My goal is to describe different approaches to the same problems and highlight pros and cons of each one. Perhaps, pick a favorite one and promote it.  Right now I want to focus on two larger topics:     Designing service objects   Handling errors in domain logic. Exceptions, values, result objects   This is a first post of the series, and it will cover the first topic: building helpful service objects.  We will go through the basics: what are we talking about when we say “service object”. We’ll look through different approaches and see which ones bring the most benefit and which ones should probably be put to rest. In the end, I’m going to suggest a working design and a couple of guidelines you can use to improve your service object game.">


  <meta name="author" content="Igor Morozov">
  
  <meta property="article:author" content="Igor Morozov">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Igor writing about things">
<meta property="og:title" content="Designing helpful service objects. Part 1. Choosing the right design">
<meta property="og:url" content="https://www.morozov.is/2020/06/01/helpful-service-objects-part-1-chosing-right-design.html">


  <meta property="og:description" content="I’ve been programming for a long time and I’ve had countless arguments about different things. I’d like to list top four reasons I’ve had an argument online.  Style guide. Thankfully, the number of arguments reduces as I mature, but I’m still spending a lot of time on them. I’d rather have an extremely opinionated styleguide and just stop talking about it. Something like wemake-python-styleguide, but for Ruby.  Monads. I have to admit that this word is almost banned from my vocabulary because of how many arguments I’ve had about it. It’s getting better, but people still like to argue about them. I wrote an article recently about them in hope to show that there’s nothing special to argue about – monads are just abstractions that may or may not be helpful. It all depends on your problems and approaches.  How to design domain logic. It may be an extremely interesting and helpful discussion, or it may turn into a useless argument. When it goes bad, it’s usually because we’re trying to discuss insignificant details and lower-level things. Where do we put arguments? What about dependency injection? How do we use instance variables? Fat model? Service objects? Ughh!  Different interpretation of common terminology. What do we mean when we say “interactor”? What about “architecture”? Is it a state when we’re just passing values from function to function? Is duck typing really an absence of types? What is a type, anyway? What does it mean to write “object oriented” code? What about “functional” approach? Do we need immutability in OO design? Those topics lead to endless discussions with little output.  As much as I love learning about new things, those arguments are extremely energy-draining. They got me thinking: since we’re usually going over the same thing, why don’t we just dump the knowledge somewhere and refer to it instead of arguing? That’s what I’m going to do.  I’m starting a series of blog posts about different topics in Ruby world. My goal is to describe different approaches to the same problems and highlight pros and cons of each one. Perhaps, pick a favorite one and promote it.  Right now I want to focus on two larger topics:     Designing service objects   Handling errors in domain logic. Exceptions, values, result objects   This is a first post of the series, and it will cover the first topic: building helpful service objects.  We will go through the basics: what are we talking about when we say “service object”. We’ll look through different approaches and see which ones bring the most benefit and which ones should probably be put to rest. In the end, I’m going to suggest a working design and a couple of guidelines you can use to improve your service object game.">



  <meta property="og:image" content="https://www.morozov.is/assets/images/posts/service_objects/part_one.png">





  <meta property="article:published_time" content="2020-06-01T18:57:00+00:00">






<link rel="canonical" href="https://www.morozov.is/2020/06/01/helpful-service-objects-part-1-chosing-right-design.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Igor Morozov",
      "url": "https://www.morozov.is/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Igor writing about things Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <a href="/">
          <img src="/assets/images/bio-photo.jpg" alt="Igor Morozov" itemprop="image">
        </a>
      
    </div>
  

  <div class="author__content">
    
      <a href="/"><h3 class="author__name" itemprop="name">Igor Morozov</h3></a>
    
    
      <div class="author__bio" itemprop="description">
        <p>I’m a software engineer familiar with Ruby, Python, JavaScript and ReasonML.
<br />
I’m enthusiastic about functional programming, Ruby, DDD and emotions.
<br />
I’m not much of a Rails person. dry-rb, mostly.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      

      
        <li>
          <a href="mailto:igor@morozov.is">
            <meta itemprop="email" content="igor@morozov.is" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/morozzzko" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span>
          </a>
        </li>
      

      

      
        <li>
          <a href="https://www.linkedin.com/in/igor-morozov" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span>
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/Morozzzko" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      
<li>
  <a href="/talks" itemprop="sameAs">
    <i class="fas fa-chalkboard-teacher" aria-hidden="true"></i> Talks
  </a>
</li>

    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Designing helpful service objects. Part 1. Choosing the right design">
    <meta itemprop="description" content="I’ve been programming for a long time and I’ve had countless arguments about different things. I’d like to list top four reasons I’ve had an argument online.Style guide. Thankfully, the number of arguments reduces as I mature, but I’m still spending a lot of time on them. I’d rather have an extremely opinionated styleguide and just stop talking about it. Something like wemake-python-styleguide, but for Ruby.Monads. I have to admit that this word is almost banned from my vocabulary because of how many arguments I’ve had about it. It’s getting better, but people still like to argue about them. I wrote an article recently about them in hope to show that there’s nothing special to argue about – monads are just abstractions that may or may not be helpful. It all depends on your problems and approaches.How to design domain logic. It may be an extremely interesting and helpful discussion, or it may turn into a useless argument. When it goes bad, it’s usually because we’re trying to discuss insignificant details and lower-level things. Where do we put arguments? What about dependency injection? How do we use instance variables? Fat model? Service objects? Ughh!Different interpretation of common terminology. What do we mean when we say “interactor”? What about “architecture”? Is it a state when we’re just passing values from function to function? Is duck typing really an absence of types? What is a type, anyway? What does it mean to write “object oriented” code? What about “functional” approach? Do we need immutability in OO design? Those topics lead to endless discussions with little output.As much as I love learning about new things, those arguments are extremely energy-draining. They got me thinking: since we’re usually going over the same thing, why don’t we just dump the knowledge somewhere and refer to it instead of arguing? That’s what I’m going to do.I’m starting a series of blog posts about different topics in Ruby world. My goal is to describe different approaches to the same problems and highlight pros and cons of each one. Perhaps, pick a favorite one and promote it.Right now I want to focus on two larger topics:  Designing service objects  Handling errors in domain logic. Exceptions, values, result objectsThis is a first post of the series, and it will cover the first topic: building helpful service objects.We will go through the basics: what are we talking about when we say “service object”. We’ll look through different approaches and see which ones bring the most benefit and which ones should probably be put to rest. In the end, I’m going to suggest a working design and a couple of guidelines you can use to improve your service object game.">
    <meta itemprop="datePublished" content="2020-06-01T18:57:00+00:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Designing helpful service objects. Part 1. Choosing the right design
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#our-main-challenge-is-domain-logic">Our main challenge is domain logic</a></li>
  <li><a href="#service-objects-nudge-us-to-organize">Service objects nudge us to organize</a></li>
  <li><a href="#what-they-look-like">What they look like</a></li>
  <li><a href="#why-some-service-objects-are-more-useful-than-others">Why some service objects are more useful than others</a></li>
  <li><a href="#whats-going-to-happen-next">What’s going to happen next</a></li>
  <li><a href="#the-rabbit-hole">The rabbit hole</a></li>
</ul>

            </nav>
          </aside>
        
        <p>I’ve been programming for a long time and I’ve had countless arguments about different things. I’d like to list top four reasons I’ve had an argument online.</p>

<p><strong>Style guide.</strong> Thankfully, the number of arguments reduces as I mature, but I’m still spending a lot of time on them. I’d rather have an extremely opinionated styleguide and just stop talking about it. Something like <a href="https://github.com/wemake-services/wemake-python-styleguide">wemake-python-styleguide</a>, but for Ruby.</p>

<p><strong>Monads.</strong> I have to admit that this word is almost banned from my vocabulary because of how many arguments I’ve had about it. It’s getting better, but people still like to argue about them. I <a href="/2020/04/01/should-i-really-use-monads.html">wrote an article recently</a> about them in hope to show that there’s nothing special to argue about – monads are just abstractions that may or may not be helpful. It all depends on your problems and approaches.</p>

<p><strong>How to design domain logic.</strong> It may be an extremely interesting and helpful discussion, or it may turn into a useless argument. When it goes bad, it’s usually because we’re trying to discuss insignificant details and lower-level things. Where do we put arguments? What about dependency injection? How do we use instance variables? Fat model? Service objects? Ughh!</p>

<p><strong>Different interpretation of common terminology.</strong> What do we mean when we say “interactor”? What about “architecture”? Is it a <em>state</em> when we’re just passing values from function to function? Is duck typing <em>really</em> an absence of types? What is a type, anyway? What does it mean to write “object oriented” code? What about “functional” approach? Do we need <a href="https://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">immutability in OO design</a>? Those topics lead to endless discussions with little output.</p>

<p>As much as I love learning about new things, those arguments are extremely energy-draining. They got me thinking: since we’re usually going over the same thing, why don’t we just dump the knowledge somewhere and refer to it instead of arguing? That’s what I’m going to do.</p>

<p>I’m starting a series of blog posts about different topics in Ruby world. My goal is to describe different approaches to the same problems and highlight pros and cons of each one. Perhaps, pick a favorite one and promote it.</p>

<p>Right now I want to focus on two larger topics:</p>

<ol>
  <li>Designing service objects</li>
  <li>Handling errors in domain logic. Exceptions, values, result objects</li>
</ol>

<p>This is a first post of the series, and it will cover the first topic: building helpful service objects.</p>

<p>We will go through the basics: what are we talking about when we say “service object”. We’ll look through different approaches and see which ones bring the most benefit and which ones should probably be put to rest. In the end, I’m going to suggest a working design and a couple of guidelines you can use to improve your service object game.</p>

<!-- excerpt -->

<h1 id="our-main-challenge-is-domain-logic">Our main challenge is domain logic</h1>

<p>Service object is a common pattern in Ruby community, but you might also see something similar in other languages. Python’s <a href="https://github.com/dry-python/stories">stories</a> were greatly influenced by <a href="http://github.com/gems/dry-transactions">dry-transactions</a> and <a href="http://trailblazer.to/">Trailblazer</a> — some of the tools we could have used for service objects.</p>

<p>The sole purpose of a service object is to be a place for your domain logic. Remember the usual models vs controllers dilemma? Well, think no more. Complex domain logic goes to service objects.</p>

<p>Let’s step back a little and see why we need to care about the logic at all, and why we should care about its exact location.</p>

<p>Usually, we’re building applications that solve a set of problems for a specific business. Sometimes its logic is trivial, but usually it’s something a sophisticated system that backs a complex business. Sometimes the software <em>is</em> the product that we sell. Either way, the logic becomes complex quite easily.</p>

<p>When we’re modelling complex processes, we have to make a lot of decisions: what needs to be captured in the model; what are the names and processes; what are the boundaries; what’s the shape of our data; how to organize domain logic <em>well</em>. Service objects don’t answer all of our questions, but they <em>nudge</em> us.</p>

<h1 id="service-objects-nudge-us-to-organize">Service objects nudge us to organize</h1>

<p>When we were working with the common model-view-controller paradigm, we had to make trade-offs and try and design logic using what we’ve got: models and controllers. Concerns, if we’re advanced enough. We put domain logic in the models, application logic in the controllers, and we get our happily ever after.</p>

<p>What if the logic doesn’t fit the model, though? It happens when the relationship is not obvious, or when the process affects multiple models. Here’s a few examples where the solution is not as obvious:</p>

<ul>
  <li>Does an applicant get a job at a company, or does the company hire the applicant?</li>
  <li>Does a buyer sell the goods, or does the customer buy the goods?</li>
  <li>What if we’re trying to match people by their taste in music? How do we measure it? Is it <code class="language-plaintext highlighter-rouge">jane#compare(john)</code>, or is it the other way around? Is it something else?</li>
  <li>What if we’re firing someone? Does a manager fire the person? Does the person fire themself? What if HR initiated the process, not the manager? What if it’s a layoff?</li>
</ul>

<p>Sometimes, the processes in our business are a bit more complex to be <em>reasonably</em> put into a specific model. There are usually different solutions:</p>

<p><strong>Add multiple entry points</strong> like <code class="language-plaintext highlighter-rouge">Group#add</code> and <code class="language-plaintext highlighter-rouge">User#add_to_group</code>. Works best if you’ve found a way to avoid duplication.</p>

<p><strong>Create a new model.</strong> It works best if the model matches the real-world domain. It’s reasonable to have a <code class="language-plaintext highlighter-rouge">JobApplication</code> which can be accepted or rejected.</p>

<p><strong>Use different models in different contexts.</strong> It’s easier to make decisions when we contextualize things. This way, similar entities have different behavior, depending on the context.</p>

<p><strong>Extract the logic</strong> into a function / procedure. It feels quite natural to have an option to call <code class="language-plaintext highlighter-rouge">hire_candidate</code>.</p>

<p class="notice--info"><strong>Note:</strong> I’ve been saying “model” quite a lot. It’s not always about ActiveRecord::Model, though. It can be a plain Ruby object or Sequel::Model too.</p>

<p>Service objects nudge us to to the latter – extract the logic into a function or a procedure. Except, we’re using classes and objects instead of “real” functions. Hence the name “service objects”.</p>

<p>It’s not a silver bullet by any chance, but it’s a nice tool which you can combine with other approaches to build better software.</p>

<h1 id="what-they-look-like">What they look like</h1>

<p>Here’s the thing about service object: it’s not really a well-documented pattern. People try to figure out how to design them in a meaningful way, and they get different results. There’s a lot of ways to categorize the service objects, with different level of detail. I’m going to take a shot and categorize by the service object behavior.</p>

<p><strong>The doer</strong> is an service object which has the <code class="language-plaintext highlighter-rouge">-er</code> suffix in the name. It has a name like <code class="language-plaintext highlighter-rouge">OrderCreator</code>, <code class="language-plaintext highlighter-rouge">UserRenamer</code>, <code class="language-plaintext highlighter-rouge">PurchasePlacer</code> or something similar. This object looks like it’s a person fulfilling their job, and usually doesn’t exist in anyone’s vocabulary, except for the developers. In some cases, it may clash with the terminology as <code class="language-plaintext highlighter-rouge">OrderCreator</code> may be both a person who placed the order <em>and</em> a service object. The doer usually has one public method named <code class="language-plaintext highlighter-rouge">call</code>, <code class="language-plaintext highlighter-rouge">perform</code>, or the one matching its purpose: <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">assign</code>, etc.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OrderCreator</span>
  <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># or call / perform / etc</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>The multitool</strong> is a service which fulfills many jobs at once. For instance, <code class="language-plaintext highlighter-rouge">OrderManager</code> may assign and remove couriers, update delivery dates and even cancel the order. Everything is centered around a specific entity.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OrderManager</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> 
    <span class="o">...</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> 
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">reschedule</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> 
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>The event</strong> is a service object which models a process which starts when <em>a specific event</em> occurs. It’s usually a complex multi-step process. The name usually captures the name of the event: <code class="language-plaintext highlighter-rouge">ApplicationSubmitted</code>, <code class="language-plaintext highlighter-rouge">OrderShipped</code>, <code class="language-plaintext highlighter-rouge">UserBlocked</code>, and so on.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OrderPlaced</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># or handle / perform / etc</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>The command</strong> is a lot similar to <em>the event</em>, except it’s designed as an imperative action in your domain. The object has a name similar to <code class="language-plaintext highlighter-rouge">SubmitApplication</code>, <code class="language-plaintext highlighter-rouge">SubmitOrder</code>, <code class="language-plaintext highlighter-rouge">BlockUser</code>, etc. It may look like <em>the doer</em> except for one major difference: it has a proper naming. People also call it an “operation”, or even a “use case” or an “interactor”.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubmitOrder</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># or handle / perform / etc</span>
    <span class="o">...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Other service object implementations usually fit within one of those four groups. If I’ve missed out on something, please let me know at <a href="mailto:igor@morozov.is">igor@morozov.is</a>.</p>

<p>I’m going to be blunt and say that you should probably throw away <em>the doer</em> and <em>the multitool</em> and replace them with something else if you’re using them. Let’s see what their problem is:</p>

<p><strong>The doer</strong> is like <em>the command</em>, except it has a poor naming. Instead of capturing something real like an action, it’s modelled as if it’s a full-grown entity in your business. In most cases your business does <em>not</em> have a <code class="language-plaintext highlighter-rouge">SomethingCreator</code>, but it has an process to <code class="language-plaintext highlighter-rouge">CreateSomething</code>. There’s a huge benefit in speaking a natural language instead of inventing your own, so my advise is <strong>turn all doers into commands</strong>.</p>

<p><strong>The multitool</strong> is a nice attempt at a service object, but has a couple of fundamental flaws.</p>

<ul>
  <li>Similar to <em>the doer</em>, the name doesn’t capture domain pretty well. I’ve seen people choose names like <code class="language-plaintext highlighter-rouge">OrderManager</code> or <code class="language-plaintext highlighter-rouge">OrderService</code>. Neither of those really exists in the domain.</li>
  <li>Is it really a “service”, or is it a model in disguise? You may achieve similar level of isolation by extracting the logic to a module / a concern and including it to your model.</li>
</ul>

<p>While I can totally understand the desire to use this design because it extracts and isolates the logic and makes it <em>feel</em> like everything is better, I’d advise everyone to take a deeper look at their own paradigm and see if there are better tools to solve the same problems.</p>

<p>One of the question you have to ask ourselves: why did we have to stray away from the good old object-oriented model and common Rails ways? Perhaps, we’re better off using approaches described in Eventide’s <a href="http://docs.eventide-project.org/user-guide/useful-objects.html#overview">useful object</a> manifesto, Yegor Bugaenko’s <a href="https://www.yegor256.com/elegant-objects.html">Elegant Objects</a> or Ivan Nemytchenko’s <a href="https://railshurts.com/">Rails Hurts → Painless Rails</a>. I’m no expert in any of those things, so let’s speak about useful <em>service</em> objects instead.</p>

<h1 id="why-some-service-objects-are-more-useful-than-others">Why some service objects are more useful than others</h1>

<p>In his RubyRussia 2019 talk <a href="https://www.youtube.com/watch?v=DfU6H-8qal8">“The future of dependency management in Ruby”</a> Anton Davydov mentioned the problems with service objects and showed the many ways to use them. When he mentioned the lack of standardization, I knew I wanted to write an overview and highlight the most useful ones, so let’s do it.</p>

<figure class="">
  <img src="/assets/images/posts/service_objects/anton_name.png" alt="A slide from Anton's talk depicting at least 8 ways to name service object's method" /><figcaption>
      Oh the diversity of methods

    </figcaption></figure>

<p>As you can see, there are at least eight popular ways to name the service object’s primary method. It is not really a problem, as you just have to pick whatever works for you and stay consistent about it. I prefer <code class="language-plaintext highlighter-rouge">#call</code>, but you might want something else.</p>

<p>There’s a deeper problem: how do we actually use the objects? How do we build them? Where do we pass the parameters? What about configuration? What about dependencies? Oh my! Just take a look at the many ways to use service objects. The slide covers probably 99% of known service object usages, so kudos to Anton for putting together the list.</p>

<figure class="">
  <img src="/assets/images/posts/service_objects/anton_use.png" alt="A slide from Anton's talk depicting at least 5 ways to use service objects" /><figcaption>
      The problematic variety of ways

    </figcaption></figure>

<p>Let’s make sure we’re on the same page about terminology before going on.</p>

<p>When we’re talking about <code class="language-plaintext highlighter-rouge">params</code>, we’re usually talking about ordinary data that we pass to the object. It’s the same arguments we would normally pass to a method that does something.</p>

<p>Dependencies are a bit more tricky. Usually, our service objects can’t perform a task on their own. They need to know how to retrieve data from the database, how to send an e-mail, how to run some related logic. It’s impractical to implement all of this ourselves, so we <em>delegate</em> it to some external objects, services and modules. <em>Those</em> are the dependencies. They’re the owners of the knowledge.</p>

<p>Options are a bit like dependencies, but simpler. It’s a run-time configuration. Rule of thumb: if you’ve put some magic numbers, strings or other values in a constant, it’s likely one of <em>those</em> options.</p>

<p>Now that we’re clear about shared terminology, let’s speak about the list. I’ve rearranged it and split the items in three groups. The result is heavily opinionated, so I’ll explain it afterwards.</p>

<p><strong>The most helpful</strong> service objects are the ones which give you the most power. They’re arguably the most pragmatic ones.</p>

<ul>
  <li>Service.new(options).call(params)</li>
  <li>Service.new(dependencies).call(params), which is almost the same as the example above</li>
  <li>Service.new.call(params), <em>only if</em> it’s a shorthand for the first two options with reasonable defaults</li>
  <li>Service.call(params), when it’s an instance created via the first three options. i.e. <code class="language-plaintext highlighter-rouge">Service = OtherService.new(...)</code></li>
</ul>

<p><strong>Moderately helpful</strong> won’t bring you as much benefit, but they’re still decent if you use them well</p>

<ul>
  <li>Service.call(params), when you just don’t need to instantiate anything. You won’t get the benefit of configuration, dependency injection or anything, but it’s still a decent piece of logic</li>
  <li>Service.new.call(params). It’s not really helpful if you cant’t configure it at all, but oh well. A future-proof design may be helpful though.</li>
</ul>

<p><strong>Not really helpful</strong> are redundant or just poorly designed. You should probably reconsider when you meet one</p>

<ul>
  <li>Service.new(params).call</li>
  <li>Service.call(params) is bad if it’s just a shorthand for most of the <code class="language-plaintext highlighter-rouge">new.call</code> variations</li>
</ul>

<p>This classification is purely opinion-based, yet there’s reasoning behind all this. It’s mostly based on my own experience in software engineering, and a couple of other ideas. It mostly comes from the fact that I like my code to be deterministic and easily modifiable. I’m also a little product-oriented, so I fiddle around with different configuration quite often.</p>

<p><strong>Each object must have a reasonable lifetime.</strong> Service objects are essentially complex functions and procedures, and their lifetime should <em>probably</em> be similar to one of any other function, module or class. Even if we’re into OOP, instantiating and object which can only be used once before being discarded seems to go against the general idea. Sure, there are cases where the function lifetime should be short, but those cases require extra thought.</p>

<p><strong>Logic should be easily extendable.</strong> Especially if we’re building a start-up which is rapidly evolving. Want to pay your contractors a 10% bonus instead of a usual 5%? Just configure the service and use it. Handy for rapid and cheap experimenting. Want to refund a user <em>even though we normally don’t</em>? Just use the service with a different set of policies. Works best if I don’t have to write any code to customize it.</p>

<p><strong>Code should expose bad design</strong> instead of promoting it. Writing an overly complex logic should be possible, yet the code must <em>look and feel</em> overly complex. This way, you’ll be able to improve your design before it becomes too time-consuming to maintain.</p>

<p><strong>No mutable state</strong> is a common idea in functional programming and a <a href="https://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">not-that-common idea in the OOP world</a>. It adds verbosity, but <strong>verbosity is not a problem</strong>. We’ll get better reusability, testability and composability if we follow the rule.</p>

<p><strong>Services should be composable</strong>. It means we should be able to organize them in a nice pipeline to avoid clumsy interfaces. We can achieve it by returning composable values, like result objects, monads and stuff like this.</p>

<p><strong>Our logic should be insighful.</strong> The code should help us figure out how the world works. We need to learn about our processes, their limitations and core participants. The complexity of the process, points of pressure, possible bugs and likely mismatch with the real-world domain. The code should help us gather the insights instead of obfsucating them.</p>

<p>That said, I’ve found that I get the most benefit when I’m using a constructor to configure the service object and provide dependencies, and pass the input parameters to the <code class="language-plaintext highlighter-rouge">#call</code> itself. It’s a bit more verbose because I have to explicitly declare all dependencies and I have to pass variables around. It brings a great benefit as I can <em>feel</em> that I have to refactor this place when it gets too complex. I also heavily use default dependencies, so I don’t have to be <em>too</em> explicit.</p>

<p>Whenever I feel like there’s no need to configure, or when the team has a different convention, I like to use class methods and avoid instances. This way, I’m still getting the benefits of a good lifetime <em>and</em> I get to expose the overly complex design. This works pretty well too.</p>

<div class="notice--info">
  <p>
    <strong>Q:</strong> why use class methods when you can just use a module?
  </p>
  <p>
    <strong>A:</strong> I like to think that modules are meant to be included into your classes, or serve as a namespace. There's nothing wrong with using module methods instead, though.
  </p>
</div>

<p>Other designs, especially the <code class="language-plaintext highlighter-rouge">new(params).call</code> have failed to meet my expectations. Its only benefit is that I can utilize instance variables to save myself a few taps. I don’t want to trade off all the benefits for that.</p>

<p>I’ll stick to the <code class="language-plaintext highlighter-rouge">new(options/dependencies).call(params)</code>, as this is the most powerful way to use service objects. We’re going to dive deeper into the practice in the next part, so here’s the design that I’m promoting:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># A service object which pays a baker a bonus for an order</span>
<span class="c1"># It's a command, or an operation</span>

<span class="k">class</span> <span class="nc">RewardBaker</span>
  <span class="nb">attr_reader</span> <span class="ss">:bonus_ratio</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="ss">bonus_ratio: </span><span class="p">)</span>
    <span class="vi">@bonus_ratio</span> <span class="o">=</span> <span class="n">bonus_ratio</span>
    <span class="c1"># &lt;= any other dependency / configuration goes here</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="o">...</span> <span class="c1"># &lt;= logic goes here</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">reward_baker</span> <span class="o">=</span> <span class="no">RewardBaker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">bonus_ratio: </span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># a 5% bonus is nice</span>
<span class="n">reward_baker</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">other_order</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="whats-going-to-happen-next">What’s going to happen next</h1>

<p>Service objects are a large enough topic, and I can’t cover them in one post. If I do, only a few people will have the time to read it – it’s going to be too overwhelming. So I’m going to release at least two more parts: “the practice” and “the next level”.</p>

<p>The practice will be a design exercise where we model a business process and illustrate decisions and trade-offs of service objects. It’s going to show how to use the event and the command and why those designs have a name which looks like they come from CQRS, Event-Sourcing or something similar.</p>

<p>In “The next level” I’ll talk about techniques which will help you get more from service objects: reduce boilerplate, organize a pipeline, and gather more insights. Afterwards I’ll address some of the flaws. I’ll finish it with a small guideline on designing service objects. I’ll also address some of my claims about the design decisions.</p>

<h1 id="the-rabbit-hole">The rabbit hole</h1>

<p>If you want to go down the rabbit hole and discover more yourself, feel free to dig through the resources I’ve mentioned below. Make sure to check the first two articles. They criticize service objects and provide nice alternatives — those may be extremely helpful for you too.</p>

<p>Avdi Grimm <a href="https://avdi.codes/service-objects/">highlights the possible problems</a> of service objects and provides alternatives. The “Domain-driven design” part is important, you should totally read it.</p>

<p>Jason Swett wrote a <a href="https://www.codewithjason.com/rails-service-objects/">nice piece</a> addressing service objects and their problem.</p>

<p>Toptal has a <a href="https://www.toptal.com/ruby-on-rails/rails-service-objects-tutorial">solid article on service objects</a> which gives some advise on good designs. You may notice that I don’t agree with it, but it’s alright. You may like their reasoning more. Check it out.</p>

<p><a href="https://railshurts.com/">Ivan Nemytchenko’s book on Painless Rails</a>. If you like Rails, but not quite, this book might help you improve your game without service objects.</p>

<p><a href="https://www.youtube.com/watch?v=DfU6H-8qal8">The future of dependency management in Ruby</a> by Anton Davydov</p>

<p><a href="http://docs.eventide-project.org/user-guide/useful-objects.html#overview">Useful objects</a> manifesto by eventide</p>

<p>Hanami guide has a <a href="https://guides.hanamirb.org/architecture/interactors/">decent article on the pattern</a> and how to use it.</p>

<p><a href="http://github.com/gems/dry-transactions">dry-transactions</a> — a once-popular gem, which used to be deprecated, but right now it’s going throw a rework. It’s a DSL for domain logic, which essentially implements the “service object” and “railway oriented programming” ideas in a nice way</p>

<p><a href="http://trailblazer.to/">Trailblazer</a> was aimed to simplify our lives and domain logic, and brought a lot of new ideas to Ruby world</p>

<p><a href="https://github.com/dry-python/stories">How Python devs implemented the idea</a></p>

<p><a href="https://github.com/wemake-services/wemake-python-styleguide">Most strict linter for Python</a>. I want something like this in Ruby. Hopefully, <a href="https://github.com/testdouble/standard">Standard</a> will help with that.</p>

<p><a href="https://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">Yegor Bugaenko’s blog</a> contains a lot of controversial and thought-provoking content. One of the ideas is that immutable objects should be a default in the object-oriented paradigm.</p>

<p><a href="https://www.yegor256.com/elegant-objects.html">Yegor Bugaenko wrote a book</a> on his ideas. If you want a different look on OOP, it’s definitely going to help you.</p>

<p>I wrote <a href="/2020/04/01/should-i-really-use-monads.html">Should I really use monads?</a> to discuss a smaller topic which comes with service objects: monads. Together those two abstractions enable you to do railway oriented programming, which is nice.</p>

<p>Rob Race’s article on <a href="https://hackernoon.com/the-3-tenets-of-service-objects-c936b891b3c2">3 tenets of service objects</a>. It was an interesting read.</p>

<p>Scott Domes shows the <code class="language-plaintext highlighter-rouge">ServiceObject.call(args)</code> as a shorthand for <code class="language-plaintext highlighter-rouge">new(args).perform</code> in <a href="https://medium.com/@scottdomes/service-objects-in-rails-75ca74214b77">Service objects in Rails</a>.</p>

        
      </section>

      <footer class="page__meta">
        
        


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-06-01T18:57:00+00:00">June 1, 2020</time></p>


      </footer>

      <section class="page__share">
    
        <a href="https://www.reddit.com/r/ruby/comments/gvbrg2/designing_helpful_service_objects_part_1_choosing/" class="btn btn--reddit" title="Discuss @ Reddit">
            <i class="fab fa-fw fa-reddit" aria-hidden="true"></i><span> See discussion @ Reddit</span>
        </a>
    

    <a href="https://twitter.com/intent/tweet?text=Designing+helpful+service+objects.+Part+1.+Choosing+the+right+design%20https%3A%2F%2Fwww.morozov.is%2F2020%2F06%2F01%2Fhelpful-service-objects-part-1-chosing-right-design.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.morozov.is%2F2020%2F06%2F01%2Fhelpful-service-objects-part-1-chosing-right-design.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

    <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fwww.morozov.is%2F2020%2F06%2F01%2Fhelpful-service-objects-part-1-chosing-right-design.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>



      
  <nav class="pagination">
    
      <a href="/2020/04/01/should-i-really-use-monads.html" class="pagination--pager" title="Should I really use monads?
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Igor Morozov. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
